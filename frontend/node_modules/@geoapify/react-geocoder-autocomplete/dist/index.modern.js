import React, { useRef, useEffect } from 'react';
import { GeocoderAutocomplete } from '@geoapify/geocoder-autocomplete';

var GeoapifyApiKey = React.createContext('');
var GeoapifyContext = function GeoapifyContext(props) {
  return React.createElement(GeoapifyApiKey.Provider, {
    value: props.apiKey
  }, props.children);
};
var GeoapifyGeocoderAutocomplete = function GeoapifyGeocoderAutocomplete(_ref) {
  var placeholderValue = _ref.placeholder,
      typeValue = _ref.type,
      langValue = _ref.lang,
      limitValue = _ref.limit,
      valueValue = _ref.value,
      filterByCountryCodeValue = _ref.filterByCountryCode,
      filterByCircleValue = _ref.filterByCircle,
      filterByRectValue = _ref.filterByRect,
      filterByPlaceValue = _ref.filterByPlace,
      biasByCountryCodeValue = _ref.biasByCountryCode,
      biasByCircleValue = _ref.biasByCircle,
      biasByRectValue = _ref.biasByRect,
      biasByProximityValue = _ref.biasByProximity,
      positionValue = _ref.position,
      countryCodesValue = _ref.countryCodes,
      debounceDelayValue = _ref.debounceDelay,
      skipIconsValue = _ref.skipIcons,
      skipSelectionOnArrowKeyValue = _ref.skipSelectionOnArrowKey,
      allowNonVerifiedHouseNumberValue = _ref.allowNonVerifiedHouseNumber,
      allowNonVerifiedStreetValue = _ref.allowNonVerifiedStreet,
      addDetailsValue = _ref.addDetails,
      preprocessHookValue = _ref.preprocessHook,
      postprocessHookValue = _ref.postprocessHook,
      suggestionsFilterValue = _ref.suggestionsFilter,
      sendGeocoderRequestFuncValue = _ref.sendGeocoderRequestFunc,
      sendPlaceDetailsRequestFuncValue = _ref.sendPlaceDetailsRequestFunc,
      placeSelectCallback = _ref.placeSelect,
      suggestionsChangeCallback = _ref.suggestionsChange,
      userInputCallback = _ref.onUserInput,
      openCallback = _ref.onOpen,
      closeCallback = _ref.onClose;
  var apiKey = React.useContext(GeoapifyApiKey);
  var geocoderContainer;
  var geocoderAutocomplete = useRef();
  var placeSelectCallbackRef = useRef();
  var suggestionsChangeCallbackRef = useRef();
  var userInputCallbackRef = useRef();
  var openCallbackRef = useRef();
  var closeCallbackRef = useRef();
  placeSelectCallbackRef.current = placeSelectCallback;
  suggestionsChangeCallbackRef.current = suggestionsChangeCallback;
  userInputCallbackRef.current = userInputCallback;
  openCallbackRef.current = openCallback;
  closeCallbackRef.current = closeCallback;
  var onSelect = React.useCallback(function (value) {
    if (placeSelectCallbackRef.current) {
      placeSelectCallbackRef.current(value);
    }
  }, []);
  var onSuggestions = React.useCallback(function (value) {
    if (suggestionsChangeCallbackRef.current) {
      suggestionsChangeCallbackRef.current(value);
    }
  }, []);
  var onUserInput = React.useCallback(function (input) {
    if (userInputCallbackRef.current) {
      userInputCallbackRef.current(input);
    }
  }, []);
  var onOpen = React.useCallback(function (opened) {
    if (openCallbackRef.current) {
      openCallbackRef.current(opened);
    }
  }, []);
  var onClose = React.useCallback(function (opened) {
    if (closeCallbackRef.current) {
      closeCallbackRef.current(opened);
    }
  }, []);
  useEffect(function () {
    if (!geocoderAutocomplete.current) {
      geocoderAutocomplete.current = new GeocoderAutocomplete(geocoderContainer, apiKey, {
        placeholder: placeholderValue || "",
        addDetails: addDetailsValue,
        skipIcons: skipIconsValue,
        skipSelectionOnArrowKey: skipSelectionOnArrowKeyValue,
        allowNonVerifiedHouseNumber: allowNonVerifiedHouseNumberValue,
        allowNonVerifiedStreet: allowNonVerifiedStreetValue,
        debounceDelay: debounceDelayValue || 100
      });
    }

    geocoderAutocomplete.current.on("select", onSelect);
    geocoderAutocomplete.current.on("suggestions", onSuggestions);
    geocoderAutocomplete.current.on("input", onUserInput);
    geocoderAutocomplete.current.on("close", onClose);
    geocoderAutocomplete.current.on("open", onOpen);

    if (sendGeocoderRequestFuncValue) {
      geocoderAutocomplete.current.setSendGeocoderRequestFunc(sendGeocoderRequestFuncValue);
    }

    return function () {
      if (geocoderAutocomplete.current) {
        geocoderAutocomplete.current.off("select", onSelect);
        geocoderAutocomplete.current.off("suggestions", onSuggestions);
        geocoderAutocomplete.current.off("input", onUserInput);
        geocoderAutocomplete.current.off("close", onClose);
        geocoderAutocomplete.current.off("open", onOpen);
      }
    };
  }, []);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setType(typeValue);
    }
  }, [typeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setLang(langValue);
    }
  }, [langValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
      geocoderAutocomplete.current.addBiasByProximity(positionValue);
    }
  }, [positionValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
      geocoderAutocomplete.current.addFilterByCountry(countryCodesValue);
    }
  }, [countryCodesValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setLimit(limitValue);
    }
  }, [limitValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setValue(valueValue || "");
    }
  }, [valueValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByCountry(filterByCountryCodeValue);
    }
  }, [filterByCountryCodeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByCircle(filterByCircleValue);
    }
  }, [filterByCircleValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByRect(filterByRectValue);
    }
  }, [filterByRectValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByPlace(filterByPlaceValue);
    }
  }, [filterByRectValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByCountry(biasByCountryCodeValue);
    }
  }, [biasByCountryCodeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByCircle(biasByCircleValue);
    }
  }, [biasByCircleValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByRect(biasByRectValue);
    }
  }, [biasByRectValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByProximity(biasByProximityValue);
    }
  }, [biasByProximityValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setPreprocessHook(preprocessHookValue);
    }
  }, [preprocessHookValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setPostprocessHook(postprocessHookValue);
    }
  }, [postprocessHookValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setSuggestionsFilter(suggestionsFilterValue);
    }
  }, [suggestionsFilterValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && sendGeocoderRequestFuncValue) {
      geocoderAutocomplete.current.setSendGeocoderRequestFunc(sendGeocoderRequestFuncValue);
    }
  }, [sendGeocoderRequestFuncValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && sendPlaceDetailsRequestFuncValue) {
      geocoderAutocomplete.current.setSendPlaceDetailsRequestFunc(sendPlaceDetailsRequestFuncValue);
    }
  }, [sendPlaceDetailsRequestFuncValue]);
  return React.createElement("div", {
    className: "geocoder-container",
    style: {
      position: "relative"
    },
    ref: function ref(el) {
      return geocoderContainer = el;
    }
  });
};

export { GeoapifyApiKey, GeoapifyContext, GeoapifyGeocoderAutocomplete };
//# sourceMappingURL=index.modern.js.map
